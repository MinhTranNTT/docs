# 生成随机数

```rust
/// 生成随机数
pub mod nums {
    // 引入随机数生成器相关的库
    use rand::Rng;

    // 引入均匀分布和分布函数的库
    use rand::distributions::{Distribution, Standard, Uniform};

    // 引入正态分布和分布函数的库
    use rand_distr::{Alphanumeric, Normal, NormalError};

    // 这段代码使用了 Rust 的 rand crate（随机数生成库），生成了不同类型的随机数，并打印出来。
    // let mut rng = rand::thread_rng(); 创建了一个随机数生成器（RNG），使用了当前线程作为种子。
    // rng.gen::<u8>() 通过 gen 方法生成一个 u8 类型的随机数。
    // 同样的方法可以生成 u16、u32、i32 和 f64 类型的随机数。
    // 最后通过 println! 宏打印出来。
    fn num1() {
        // 创建一个随机数生成器
        let mut rng = rand::thread_rng();

        // 生成一个随机的 8 位无符号整数，并打印
        println!("Random u8: {}", rng.gen::<u8>());

        // 生成一个随机的 16 位无符号整数，并打印
        println!("Random u16: {}", rng.gen::<u16>());

        // 生成一个随机的 32 位无符号整数，并打印
        println!("Random u32: {}", rng.gen::<u32>());

        // 生成一个随机的 32 位有符号整数，并打印
        println!("Random i32: {}", rng.gen::<i32>());

        // 生成一个随机的浮点数，并打印
        println!("Random float: {}", rng.gen::<f64>());
    }

    // rng.gen_range() 通过 gen_range 方法生成一个区间范围内的随机数，但是该方法需要传入一个范围参数，否则编译时会出错。
    fn num2() {
        let mut rng = rand::thread_rng();

        // 新版本的Rust中，数字区间的语法已经改为双点号 (..)
        // println!("Integer: {}", rng.gen_range(0, 10));
        println!("Integer: {}", rng.gen_range(0..10));
        println!("Float: {}", rng.gen_range(0.0..10.0));
    }

    // 这段代码报错是因为 sample 方法需要的是一个泛型类型实现了 Distribution trait，但是这里的 Uniform 类型并没有实现 Distribution trait，导致编译器无法通过类型检查。
    // 要解决这个问题，可以通过为 Uniform 类型实现 Distribution trait 的方式来解决。修改代码如下：
    // 这里我们通过为 Uniform 类型实现 Distribution trait 并改用 rng.sample(die) 方法来生成随机数。
    fn num3() {
        // 创建一个随机数生成器
        let mut rng = rand::thread_rng();

        // 创建一个区间为 [1, 6] 的均匀分布
        let die = Uniform::from(1..7);

        // 进入一个无限循环
        loop {
            // 从均匀分布中抽取一个随机样本，表示掷骰子的结果
            let throw = die.sample(&mut rng);

            // 打印掷骰子的结果
            println!("Roll the die: {}", throw);

            // 如果掷骰子的结果为 6，则跳出循环
            if throw == 6 {
                break;
            }
        }
    }

    // 定义一个函数，返回类型为 `Result<(), NormalError>`，可能出现错误类型为 `NormalError`
    fn num4_() -> Result<(), NormalError> {
        // 创建一个随机数生成器
        let mut rng = rand::thread_rng();

        // 创建一个均值为 2，标准差为 3 的正态分布
        let normal = Normal::new(2.0, 3.0)?;

        // 从正态分布中抽取一个随机样本
        let v = normal.sample(&mut rng);

        // // 打印抽取的随机样本
        println!("{} is from a N(2, 9) distribution", v);

        // // 表示 `num4_` 函数执行成功
        Ok(())
    }

    fn num4() {
        // 如果 `num4_` 函数执行失败，则产生一个 panic，打印出 "TODO: panic message" 这个字符串
        num4_().expect("TODO: panic message");
    }

    // `Point` doesn't implement `Debug`
    #[derive(Debug)]
    #[allow(unused)]
    struct Point {
        x: i32,
        y: i32,
    }

    impl Distribution<Point> for Standard {
        fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> Point {
            let (rand_x, rand_y) = rng.gen();
            Point {
                x: rand_x,
                y: rand_y,
            }
        }
    }

    fn num5() {
        let mut rng = rand::thread_rng();
        let rand_tuple = rng.gen::<i32>();
        let rand_point: Point = rng.gen();
        println!("Random tuple: {:?}", rand_tuple);
        println!("Random Point: {:?}", rand_point);
    }

    // 生成每一行的代码注释，并且注释为中文
    fn num6() {
        // 使用 Rust 的线程随机数生成器生成一个包含 30 个字母和数字的随机字符串
        let rand_string: String = rand::thread_rng() // 创建一个新的线程随机数生成器
            .sample_iter(&Alphanumeric) // 采样字母和数字
            .take(30) // 只取 30 个元素
            .map(char::from) // 将每个元素映射到一个字符
            .collect(); // 将字符收集到一个字符串中
        println!("{}", rand_string);
    }

    fn num7() {
        // 定义一个包含所有可用字符的常量字符数组
        const CHARSET: &[u8] = b"ABCDEFGHIJKLMNOPQRSTUVWXYZ\
        abcdefghijklmnopqrstuvwxyz\
        0123456789)(*&^%$#@!~";

        const PASSWORD_LEN: usize = 30;
        let mut rng = rand::thread_rng();

        // 使用 map 函数生成一个长度为 PASSWORD_LEN 的密码字符串
        let password: String = (0..PASSWORD_LEN)
            .map(|_| {
                // 随机选择 CHARSET 中的一个字符作为密码的一位
                let idx = rng.gen_range(0..CHARSET.len());
                CHARSET[idx] as char
            })
            .collect();
        println!("{:?}", password);
    }
}

```