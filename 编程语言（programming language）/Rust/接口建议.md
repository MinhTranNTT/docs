### `#[derive(Debug)]`

`#[derive(Debug)]` 通常是最佳实现方式 -> 派生的 Trait 会为任意泛型参数添加相同的约束

```rust
use std::fmt::Debug;

#[derive(Debug)]
struct Pair<T> {
    a: T,
    b: T,
}

fn main() {
    let pair = Pair { a: 5, b: 10 };
    println!("Pair: {:?}", pair);
}

```



### 手动实现 `std::fmt::Debug`

```rust
struct Pair<T> {
    a: T,
    b: T,
}

impl<T: std::fmt::Debug> std::fmt::Debug for Pair<T> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("Pair")
            .field("a", &self.a)
            .field("b", &self.b)
            .finish()
    }
}

fn main() {
    let pair = Pair { a: 5, b: 10 };
    println!("Pair: {:?}", pair);
}
```



### `Send`

```rust
#[derive(Debug)]
struct MyBox(*mut u8);

unsafe impl Send for MyBox {}


fn main() {
    let mb = MyBox(Box::into_raw(Box::new(42)));

    // x 没有实现 Send Trait
    // let x = std::rc::Rc::new(42);
    
    std::thread::spawn(move || {
        println!("{:?}", mb);
    });
}

```



### `Clone`

```rust
#[derive(Debug, Clone)]
struct Person {
    name: String,
    age: u32,
}

impl Person {
    fn new( name: String, age: u32) -> Self {
        Self { name, age}
    }
}

fn main() {
    let p1 = Person::new("Alice".to_owned(), 25);
    let p2 = p1.clone();
    println!("P1: {:?}", p1);
    println!("P2: {:?}", p2);

}

```



### `Default`

```rust
#[derive(Default)]
struct Person {
    id: i32,
    age: i32,
}

fn main() {
    let per = Person::default();
    println!("per: ({}, {})", per.id, per.age);

}

```



### `PartialEq`

```rust
#[derive(Debug, PartialEq)]
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p1 = Point {x: 1, y: 2};
    let p2 = Point {x: 1, y: 2};
    let p3 = Point {x: 3, y: 4};
    println!("p1 == p2: {}", p1 == p2);
    println!("p1 == p3: {}", p1 == p3);

}

```



### `PartialOrd, Eq`

```rust
#[derive(Debug, PartialEq, PartialOrd, Eq, Ord, Clone)]
struct Person {
    name: String,
    age: u32,
}

fn main() {
    let mut ages = std::collections::BTreeMap::new();

    let p1 = Person {
        name: "Alice".to_owned(),
        age: 25,
    };

    let p2 = Person {
        name: "Bob".to_owned(),
        age: 30,
    };

    let p3 = Person {
        name: "Charlie".to_owned(),
        age: 20,
    };

    ages.insert(p1.clone(), "Alice's age");
    ages.insert(p2.clone(), "Bob's age");
    ages.insert(p3.clone(), "Charlie's age");

    for (person, st) in &ages {
        println!("{}: {} - {:?}", person.name, person.age, st)
    }
}

```



### `Hash`

```rust
#[derive(Debug, PartialEq, Eq, Clone)]
struct Person {
    name: String,
    age: u32,
}

impl std::hash::Hash for Person {
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        self.name.hash(state);
        self.age.hash(state);
    }
}

fn main() {
    let mut pes = std::collections::HashSet::new();

    let p1 = Person {
        name: "Alice".to_owned(),
        age: 25,
    };

    let p2 = Person {
        name: "Bob".to_owned(),
        age: 30,
    };

    let p3 = Person {
        name: "Charlie".to_owned(),
        age: 20,
    };

    pes.insert(p1.clone());
    pes.insert(p2.clone());
    pes.insert(p3.clone());

    println!("pes: {:#?}", pes)
}

```

