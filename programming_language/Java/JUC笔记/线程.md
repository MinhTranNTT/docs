# 线程

[进程与线程-蒲公英云 (dandelioncloud.cn)](https://www.dandelioncloud.cn/article/details/1435125464791883778)

# 线程同步的方式

Java主要通过加锁的方式实现线程同步，而锁有两类，分别是synchronized和Lock。

synchronized可以加在三个不同的位置，对应三种不同的使用方式，这三种方式的区别是锁对象不同：

1. 加在普通方法上，则锁是当前的实例（this）。
2. 加在静态方法上，则锁是当前类的Class对象。
3. 加在代码块上，则需要在关键字后面的小括号里，显式指定一个对象作为锁对象。

不同的锁对象，意味着不同的锁粒度，所以我们不应该无脑地将它加在方法前了事，尽管通常这可以解决问题。而是应该根据要锁定的范围，准确的选择锁对象，从而准确地确定锁的粒度，降低锁带来的性能开销。

synchronized是比较早期的API，在设计之初没有考虑到超时机制、非阻塞形式，以及多个条件变量。若想通过升级的方式让synchronized支持这些相对复杂的功能，则需要大改它的语法结构，不利于兼容旧代码。因此，JDK的开发团队在1.5引入了Lock，并通过Lock支持了上述的功能。Lock支持的功能包括：支持响应中断、支持超时机制、支持以非阻塞的方式获取锁、支持多个条件变量（阻塞队列）。

**加分回答**

synchronized采用“CAS+Mark Word”实现，为了性能的考虑，并通过锁升级机制降低锁的开销。在并发环境中，synchronized会随着多线程竞争的加剧，按照如下步骤逐步升级：无锁、偏向锁、轻量级锁、重量级锁。

Lock则采用“CAS+volatile”实现，其实现的核心是AQS。AQS是线程同步器，是一个线程同步的基础框架，它基于模板方法模式。在具体的Lock实例中，锁的实现是通过继承AQS来实现的，并且可以根据锁的使用场景，派生出公平锁、不公平锁、读锁、写锁等具体的实现。

#### 延伸阅读

想要保证线程安全，不止线程同步一种手段，还包含如下常见办法：

1. 原子类：可以用原子方式更新一个变量，即在变量未被其他线程修改时才出发更新，否则会引发失败。
2. volatile：volatile是一个轻量级的锁，它通过保证内存可见性的办法来实现线程安全。
3. 并发工具：还有很多并发工具类，一样可以保证线程安全，如Semaphore、CountDownLatch、CyclicBarrier。

‍
